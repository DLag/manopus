sequencer:
  # Variables which will be accessible for every sequence
  # through env object
  env:
    response: "Hello "
  # List of inputs to be applied to step without specified inputs list
  default_inputs:
    - slack
  # List of outputs to be applied to step without specified outputs list
  default_outputs:
  # List of configurations of sequences
  sequences:
    - name: greating sequence # Name of the sequence for logs (optional)
      steps: # List of the sequence steps
        - name: ask for name # Name of the step for logs (optional)
          match: # List of the matching rules
            - or: # Except one rule below should return 'true'
              - field: req.direct # Field direct from input request
                value: true       # should be bool and contain true
              - field: req.mentioned # or this field should be true
                value: true          # to make 'or' statement become true
            - field: req.message
              regexp: '(Hi|hi|Hello|hello)' # Regexp match rule
          processors: # Processor which will process data from input and may return some response
            - type: bash # Processing script with Bash
              encoding: plain # Response will be  in plain text format
              script: # Bash script to be executed
                - 'echo "Hi <@$REQ_USER_ID>, what is your name?"'
              export: # List of values to be exported to the sequence context
                - current: req.user_id # Value of req.user_id will be accessible in next step
                  new: chat_user       # as export.chat_user variable
        - name: greeting
          timeout: 60
          match:
            - or:
                - field: req.direct
                  value: true
                - field: req.mentioned
                  value: true
            - field: req.user_id
              compare: export.chat_user
            - field: req.message
              regexp: '(My|my) name is (?P<name>[A-Za-z]+)'
          processors:
            - type: bash
              encoding: plain
              script:
                - echo $ENV_RESPONSE $MATCH_NAME
    - name: repeating sequence
      steps:
        - name: repeat
          match:
            - field: req.message
              regexp: '^(@.* )?Repeat: (?P<msg>.*)'
          processors:
            - type: bash
              encoding: plain
              script:
                - echo $MATCH_MSG
    - name: always direct response
      steps:
        - match:
            - field: req.message
              regexp: '^(@.* )Direct: (?P<msg>.*)'
          processors:
            - type: bash
              encoding: json
              destination: slack
              skip_callback: true
              script:
                - 'echo "{\"data\":\"$MATCH_MSG\",\"user_id\":\"$REQ_USER_ID\"}"'
    - name: sleeping sequence
      steps:
      - name: sleep
        match:
          - field: req.message
            regexp: '^sleep\((?P<duration>.*)\)'
        processors:
          - max_execution_time: 60
            type: bash
            encoding: plain
            script:
              - trap 'echo "SIGINT has been received"' SIGINT
              - sleep $MATCH_DURATION
              - echo Was sleeping for $MATCH_DURATION seconds
    - name: request debug sequence
      steps:
        - name: debug
          match:
            - or:
                - field: req.direct
                  value: true
                - field: req.mentioned
                  value: true
            - field: req.message
              regexp: '(@.* )?Debug$'
          processors:
            - type: bash
              encoding: plain
              script: ( set -o posix ; set ) | grep 'REQ_\|ENV_\|MATCH_'
    - name: Python request debug sequence
      steps:
        - name: debug
          match:
            - or:
                - field: req.direct
                  value: true
                - field: req.mentioned
                  value: true
            - field: req.message
              regexp: '(@.* )?DebugPython$'
          processors:
            - type: python
              encoding: plain
              script: |
                from pprint import pprint
                pprint(payload)
    - name: simple processor sequence
      steps:
        - name: simple
          match:
            - or:
                - field: req.direct
                  value: true
                - field: req.mentioned
                  value: true
            - field: req.message
              regexp: 'Simple$'
          processors:
            - type: simple
              destination: slack
              encoding: none
              skip_callback: true
              script:
                user_name: *slack_user
                attachments:
                  - callback_id: "several options"
                    attachment_type: "default"
                    actions:
                      - name: Option A
                        text: "Option A"
                        type: button
                        value: opt_a
                      - name: Option B
                        text: "Option B"
                        type: button
                        value: opt_b
                data: "Simple processor response"
        - name: simple callback
          match:
            - field: req.interaction
              value: true
            - field: req.actions
              operator: not_empty
          processors:
            - type: bash
              encoding: plain
              script: echo You have chosen $REQ_ACTION_NAME
    - name: HTTP request debug sequence
      steps:
        - name: http debug
          inputs:
            - http
          match:
            - field: req.http_uri
              regexp: ^/debug
          processors:
            - type: bash
              encoding: plain
              script: ( set -o posix ; set ) | grep 'REQ_\|ENV_\|MATCH_'
    - name: Message from HTTP to Slack
      steps:
        - inputs:
            - http
          match:
            - field: req.http_path
              regexp: ^/message$
            - field: req.http_form.message.0
              regexp: (?P<msg>.*)
            - field: req.http_form.user.0
              regexp: (?P<user>.*)
          processors:
            - type: bash
              encoding: json
              destination: slack
              skip_callback: true
              script:
                - echo "{\"data\":\"$MATCH_MSG\",\"user_name\":\"$MATCH_USER\"}"
            - type: bash
              encoding: plain
              script:
                - echo "Sent \"$MATCH_MSG\" to \"$MATCH_USER\""
    - name: Message from HTTP with JSON to Slack
      steps:
        - inputs:
            - http
          match:
            - field: req.http_uri
              regexp: ^/message-json
            - field: req.http_method
              value: POST
            - field: req.http_json.message
              operator: "not_empty"
            - field: req.http_json.user
              operator: "not_empty"
          processors:
            - type: bash
              encoding: json
              destination: slack
              skip_callback: true
              script:
                - 'echo "{\"data\":\"$REQ_HTTP_JSON_MESSAGE\",\"user_name\":\"$REQ_HTTP_JSON_USER\"}"'
            - type: bash
              encoding: plain
              script:
                - 'echo "Sent \"$REQ_HTTP_JSON_MESSAGE\" to \"$REQ_HTTP_JSON_USER\""'
    - name: Debug in JSON
      steps:
        - inputs:
          - http
          match:
            - field: req.http_uri
              regexp: '^/json'
          processors:
            - type: bash
              encoding: toml
              script: echo "http_code = 201"; echo "[data]"; ( set -o posix ; set ) | grep 'REQ_\|ENV_\|MATCH_' | sed "s/'//g" | sed -e "s/\(.*\)=\(.*\)/\1 = \"\2\"/g"
    - steps:
      - inputs:
          - cli
        processors:
          - type: bash
            encoding: plain
            script:
              - echo $ENV_RESPONSE $REQ_NAME